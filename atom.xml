<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>马思夫的博客</title>
  
  <subtitle>我从未长大，但从未停止生长</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maself.top/"/>
  <updated>2018-04-30T12:57:55.224Z</updated>
  <id>http://maself.top/</id>
  
  <author>
    <name>mamq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python下利用opencv提取surf特征并保存</title>
    <link href="http://maself.top/2018/04/30/python%E4%B8%8B%E5%88%A9%E7%94%A8opencv%E6%8F%90%E5%8F%96surf%E7%89%B9%E5%BE%81%E5%B9%B6%E4%BF%9D%E5%AD%98/"/>
    <id>http://maself.top/2018/04/30/python下利用opencv提取surf特征并保存/</id>
    <published>2018-04-30T08:06:00.000Z</published>
    <updated>2018-04-30T12:57:55.224Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=30352784&auto=0&height=32"></iframe><h1 id="一、算法背景介绍"><a href="#一、算法背景介绍" class="headerlink" title="一、算法背景介绍"></a>一、算法背景介绍</h1><p>Lowe于2000年提出了SIFT算法，并于2004年加以完善和改进，SIFT特征对图像旋转、平移、缩放、亮度变化能够保持良好的不变性，且其独特性好，信息量较为丰富，得到了广泛的应用，但其提取计算量较大，效率较低，因此Bay等人提出了SURF算法，在保证特征点数量的情况下，提高了效率。<br>SURF算法首先构建Hessian矩阵，然后构建尺度空间(SIFT算法则使用DOG)，其在构建图像金字塔时原始图像大小保持不变，只改变滤波器大小，然后精确定位特征点并确定其主方向，最后生成特征点描述子。<br>此外，SURF算法得到的特征向量维度为64，而SIFT得到的是128维向量。<br><a id="more"></a></p><h1 id="二、实现代码"><a href="#二、实现代码" class="headerlink" title="二、实现代码"></a>二、实现代码</h1><p>下述代码计算images_folder文件夹下的所有图片的SURF特征，然后将图片与特征向量其保存到指定文件夹<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = sys.path[<span class="number">0</span>] + os.sep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">feature_extract</span><span class="params">(images_folder, draw_folder)</span>:</span></span><br><span class="line">    featureSum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(images_folder):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.jpg'</span> <span class="keyword">in</span> filename:</span><br><span class="line">            filepath + images_folder + filename</span><br><span class="line">            drawpath = draw_folder + filename  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        img = cv2.imread(filepath)</span><br><span class="line">        filename = filepath.split(os.sep)[<span class="number">-1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">        gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)</span><br><span class="line">        <span class="comment"># set Hessian threshold</span></span><br><span class="line">        detector = cv2.xfeatures2d.SURF_create(<span class="number">2000</span>)</span><br><span class="line">        <span class="comment"># find keypoints and descriptors directly</span></span><br><span class="line">        kps, des = detector.detectAndCompute(gray, <span class="keyword">None</span>)</span><br><span class="line">        img = cv2.drawKeypoints(image=img, outImage=img, keypoints=kps, \ </span><br><span class="line">            flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS, color=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        feature_name = images_folder + <span class="string">'features%s%s.feature'</span>%(os.sep, filename)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            np.savetxt(feature_name, des, fmt=<span class="string">'%.5e'</span>) <span class="comment"># 保存特征向量</span></span><br><span class="line">            <span class="comment"># feature = np.loadtxt(feature_folder + filename) # 加载特征向量</span></span><br><span class="line">            <span class="comment"># cv2.imwrite(drawpath, img) # 保存绘制了SURF特征的图片</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        featureSum += len(kps)</span><br><span class="line">    <span class="keyword">print</span> featureSum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    images_folder = path + <span class="string">'images'</span> + os.sep</span><br><span class="line">    draw_folder = path + <span class="string">'results'</span> + os.sep + <span class="string">'drawImages'</span> + os.sep</span><br><span class="line">    feature_extract(images_folder, draw_folder)</span><br></pre></td></tr></table></figure></p><p>以上，欢迎交流～</p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=30352784&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt;

&lt;h1 id=&quot;一、算法背景介绍&quot;&gt;&lt;a href=&quot;#一、算法背景介绍&quot; class=&quot;headerlink&quot; title=&quot;一、算法背景介绍&quot;&gt;&lt;/a&gt;一、算法背景介绍&lt;/h1&gt;&lt;p&gt;Lowe于2000年提出了SIFT算法，并于2004年加以完善和改进，SIFT特征对图像旋转、平移、缩放、亮度变化能够保持良好的不变性，且其独特性好，信息量较为丰富，得到了广泛的应用，但其提取计算量较大，效率较低，因此Bay等人提出了SURF算法，在保证特征点数量的情况下，提高了效率。&lt;br&gt;SURF算法首先构建Hessian矩阵，然后构建尺度空间(SIFT算法则使用DOG)，其在构建图像金字塔时原始图像大小保持不变，只改变滤波器大小，然后精确定位特征点并确定其主方向，最后生成特征点描述子。&lt;br&gt;此外，SURF算法得到的特征向量维度为64，而SIFT得到的是128维向量。&lt;br&gt;
    
    </summary>
    
      <category term="图像处理" scheme="http://maself.top/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="python" scheme="http://maself.top/tags/python/"/>
    
      <category term="surf特征" scheme="http://maself.top/tags/surf%E7%89%B9%E5%BE%81/"/>
    
      <category term="特征提取与保存" scheme="http://maself.top/tags/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>python下进行hsv颜色空间量化</title>
    <link href="http://maself.top/2018/04/30/python%E4%B8%8B%E5%AF%B9hsv%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4%E8%BF%9B%E8%A1%8C%E9%87%8F%E5%8C%96/"/>
    <id>http://maself.top/2018/04/30/python下对hsv颜色空间进行量化/</id>
    <published>2018-04-30T05:41:49.000Z</published>
    <updated>2018-04-30T08:13:14.173Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="//music.163.com/outchain/player?type=2&id=30352784&auto=0&height=32"></iframe><p>由于工作需要，需要计算颜色直方图来提取颜色特征，但若不将颜色空间进行量化，则直方图矢量维数过高，不便于使用。但是看了<strong>opencv API</strong>后并未发现提供了相关函数能够在计算颜色直方图的同时进行量化，因此这部分功能只能自己实现。下面分为两个部分进行介绍：<br><a id="more"></a></p><h1 id="一、颜色空间量化表"><a href="#一、颜色空间量化表" class="headerlink" title="一、颜色空间量化表"></a>一、颜色空间量化表</h1><p>由于RGB模型不够直观，不符合人类视觉习惯，因此在进行颜色特征提取前，需要将照片从RGB颜色模型转换为更符合人类视觉的HSV模型。在提取颜色特征时，最常用的方法之一为颜色直方图法，但一张图片中出现的颜色一般特别多，导致直方图矢量的维数较高，因此需要对HSV空间进行量化。根据人眼对颜色的感知特性，采用较为常用的量化方法，即按照如下对应关系进行量化：<br><img src="https://img-blog.csdn.net/20180428195709157?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzOTI2NTc1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="HSV量化对照表"><br>基于上述量化表，将各颜色分量按照下述公式合成为72维一维矢量： $G = 9H + 3S + V$</p><h1 id="二、量化代码"><a href="#二、量化代码" class="headerlink" title="二、量化代码"></a>二、量化代码</h1><p>代码使用纯python写成，效率偏低，处理388*500像素的照片用时1.45秒。在quantilize函数中，未使用if-else判断语句，因此至少节省了1/3的时间。但这个速度显然是无法令人满意的，用C++效率应该会更高点。如果有人有更好的想法，欢迎在下方评论交流。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">colors</span><span class="params">(imagepath)</span>:</span></span><br><span class="line">    img = cv2.imread(imagepath)</span><br><span class="line">    hsv = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span><br><span class="line">    nhsv = np.zeros(hsv.shape[:<span class="number">2</span>], dtype=np.uint8)</span><br><span class="line">    t2 = datetime.now()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(hsv.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(hsv.shape[<span class="number">1</span>]):</span><br><span class="line">            nhsv[i][j] = quantilize(hsv[i][j])</span><br><span class="line">    <span class="keyword">print</span> datetime.now() - t2</span><br><span class="line">    hist = cv2.calcHist([nhsv], [<span class="number">0</span>], <span class="keyword">None</span>, [<span class="number">72</span>], [<span class="number">0</span>,<span class="number">72</span>]) <span class="comment"># 40x faster than np.histogramfaster than np.histogram</span></span><br><span class="line">    plt.plot(hist,color = <span class="string">'r'</span>)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">72</span>])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantilize</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="string">'''hsv直方图量化</span></span><br><span class="line"><span class="string">    value : [21, 144, 23] h, s, v</span></span><br><span class="line"><span class="string">    opencv中，h-[0,180], s-[0,255], v-[0,255]</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    value[<span class="number">0</span>] = value[<span class="number">0</span>] * <span class="number">2</span></span><br><span class="line">    hlist = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">75</span>, <span class="number">155</span>, <span class="number">190</span>, <span class="number">270</span>, <span class="number">290</span>, <span class="number">316</span>, <span class="number">360</span>]</span><br><span class="line">    svlist = [<span class="number">21</span>, <span class="number">178</span>, <span class="number">255</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(hlist)):</span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">0</span>] &lt;= hlist[i]:</span><br><span class="line">            h = i % <span class="number">8</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(svlist)):</span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">1</span>] &lt;= svlist[i]:</span><br><span class="line">            s = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(svlist)):</span><br><span class="line">        <span class="keyword">if</span> value[<span class="number">2</span>] &lt;= svlist[i]:</span><br><span class="line">            v = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span> * h + <span class="number">3</span> * s + v</span><br></pre></td></tr></table></figure></p><p>以上，欢迎批评交流～<br>如果觉得不错，欢迎点赞～</p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot; height=&quot;52&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=30352784&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;由于工作需要，需要计算颜色直方图来提取颜色特征，但若不将颜色空间进行量化，则直方图矢量维数过高，不便于使用。但是看了&lt;strong&gt;opencv API&lt;/strong&gt;后并未发现提供了相关函数能够在计算颜色直方图的同时进行量化，因此这部分功能只能自己实现。下面分为两个部分进行介绍：&lt;br&gt;
    
    </summary>
    
      <category term="图像处理" scheme="http://maself.top/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    
      <category term="python" scheme="http://maself.top/tags/python/"/>
    
      <category term="hsv量化" scheme="http://maself.top/tags/hsv%E9%87%8F%E5%8C%96/"/>
    
      <category term="颜色空间" scheme="http://maself.top/tags/%E9%A2%9C%E8%89%B2%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
</feed>
